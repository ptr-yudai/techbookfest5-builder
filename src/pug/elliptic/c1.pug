h2 前提となる知識
p 本章では，楕円曲線暗号を理解する上で最低限必要となる数学（整数論）に関する基礎的な知識を簡単に紹介する．


h3#c1s1 群の基本
p 暗号理論において，群は非常によく使われる．楕円曲線も群を成すために暗号として使うことができる．本節では，群の定義から，それに関する計算アルゴリズムまでを簡単に説明する．


h4 群の公理
p ある集合\(G\)が演算\(\bigcirc\)に対して以下の４つの性質を満たすとき，\(G\)を群(group)と呼ぶ．
ol
	li \(\exists a,b \in G\)に対して\(a \bigcirc b \in G\)
	li \(\exists a,b,c \in G\)に対して\((a \bigcirc b) \bigcirc c = a \bigcirc (b \bigcirc c)\) 【結合律】
	li \(\exists a \in G\)に対して\(a \bigcirc e = e \bigcirc a = a\)なる単位元\(e \in G\)が存在する
	li \(\forall a \in G\)に対して\(a \bigcirc a^{-1} = a^{-1} \bigcirc a = e\)なる逆元\(a^{-1} \in G\)が存在する
p これらを群の公理と呼ぶ．例えば整数の集合\(\mathbb{Z}\)は，加法に関して上記の4つの性質を満たす．（整数の和は整数であり，加算の順序は関係なく，単位元\(0\)が存在し，マイナスを掛ければ逆元となる．）一方，\(\mathbb{Z}\)は乗法に関して群にはならない．（例えば\(2\)には逆元が存在しない．）演算\(\bigcirc\)には乗算と加算がある．本稿ではそれぞれを\(+\)と\(\times\)で表し，\(\times\)については日常的な乗算と同様に省略する場合がある．また，べき演算を表すとき，次のような記法の違いがあることに注意されたい．ただし，\(n\)は正数とする．
p 加算：\(na = a + a + a + \cdots + a\)
p 乗算：\(a^n = a \times a \times a \times \cdots \times a\)
p 楕円曲線暗号においては加算がメインになってくる．また，群\(G\)の元の個数を\(G\)の位数(order)と呼び，\(\#G\)や\(|G|\)と表す．また，群\(G\)の元\(a\)のべき全体が作る集合（部分群）を\(&lt;a&gt;\)と表す．すなわち，
p \[&lt;a&gt;=\{a^k | k \in \mathbb{Z}\}\]


h4 \(\mathbb{Z}_p\)と\(\mathbb{Z}_p^{*}\)
p \(\mathbb{Z}\)は整数全体の集合を意味するが，\(\mathbb{Z}_p\)は\(0\)から\(p-1\)までの整数の集合を表す．すなわち,
p \[\mathbb{Z}_{p} = \{0,1,2,\cdots,p-1\}\]
p 特に，\(\mathbb{Z}_p\)に\(p\)を法とした加法や乗法の演算を定義すると，\(\mathbb{Z}_p\)は群の性質を満たす．また，同様に\(p\)と互いに素な整数の集合を\(\mathbb{Z}_p^{*}\)と表し，これは巡回群となる．


h3#c1s2 基礎となる定理
p 本節では，次章以降で利用する定理やアルゴリズムなどについて，簡単に説明する．プログラムをメインに載せるので，証明などは適宜調べてもらいたいと思う．


h4 Euclidの互除法
p
	| 二つの正数\(a,b\)の最大公約数を求める方法として，Euclidの互除法が有名である．Euclidの互除法を実装したプログラムを以下に示す．
	:code(lang="python")
		def gcd(a, b):
		while b != 0:
			(a, b) = (b, a % b)
		return a
p
	| さらに，正数\(a,b\)が渡されたとき，\(ax + by = gcd(a, b)\)を満たす\(x,y\)の組を見つける方法として，拡張Euclid互除法が使われる．後述する逆元や平方剰余の話でこのアルゴリズムは重要になってくる．拡張Euclid互除法を実装したプログラムを以下に示す．
	:code(lang="python")
		def xgcd(a, b):
			x0, x1, y0, y1 = 1, 0, 0, 1
			while b != 0:
				q, a, b = a // b, b, a % b
				x0, x1 = x1, x0 - q * x1
				y0, y1 = y1, y0 - q * y1
			return  a, x0, y0
h3#c1s3 合同式に関わる定理
p
	| 合同式についてはご存知の方も多いであろう．本節では，合同式に関わる定理や定義をプログラムをメインに紹介する．ただし，本稿では\(a\)と\(b\)が\(p\)を法として合同であることを\[a = b \mod p\]
	| と表す．（一般的な表し方と少し違うので注意してほしい．）


h4 合同式を解く
p
	| 整数\(a,b\)に対して，\(aX = b \mod p\)を満たすような整数\(X\)を求めることを，「合同式を解く」と言う．これは，\(a-1\)を求める問題と等しい．前節で説明した拡張Euclid互除法を使えば，\(\mathbb{Z}_p\)の元\(a\)の逆元\(a-1\)を求めることができる．\(\mathbb{Z}_p\)の元\(a\)の逆元\(a-1\)を求めるプログラムを以下に示す．ただし，前節で定義した
	code xgcd
	| を利用している．
	:code(lang="python")
		def modInv(a, p):
			g, x, y = xgcd(a, p)
		if g != 1:
			raise Exception(“逆数が存在しません”)
		return x % p
	| これにより，\(X = a^{-1}b \mod p\)として合同式を解くことができる．逆数の計算は楕円曲線暗号でも非常によく使われる．本稿では，\(a^{-1}b\)を\(b/a, \cfrac{b}{a}\)のように除算や分数の形で表すことにする．


h4 平方剰余
p
	| ある奇素数（2でない素数）\(p\)に対して，\(a\)を\(p\)と互いに素な整数とする．\(a\)がある整数\(n\)の\(p\)を法とした平方数であるとき，\(a\)を「\(p\)を法とする平方剰余（quadratic residue）」と呼ぶ．すなわち\[n^2 = a \mod p\]
	| なる整数\(n\)が存在すればよい．
p
	| 楕円曲線暗号では平方剰余を求める計算が必要になるが，すべての\(a \in \mathbb{Z}_p^{*}\)が平方剰余とは限らない．そこで，平方剰余かどうかを確認する必要があるが，ここで使われるのが
	strong Legendre記号
	| である．\(a\)が\(p\)を法として平方剰余であるかを調べるLegendre記号は\[L=\cfrac{a}{p} \mod p\]
	| で表される．\(L=1\)なら平方剰余であり，\(L=-1(=p-1)\)なら平方剰余でない．（\(L=0\)のときは\(n=0\)の1つの解を持つ．）Legendre記号を使う他に，Eulerの規準を用いても同じ結果を得られる．Legendre記号は\(p\)の逆元を計算する必要があるが，Eulerの規準ではこれが不要なため，本稿ではEulerの規準を用いる．Eulerの規準によると，\(p\)を奇素数とするとき，\[\cfrac{a}{p} = a^{(p-1)/2} \mod p\]
	| が成り立つ．
	| Eulerの規準を利用してLegendre記号を調べる関数を以下に示す．
	:code(lang="python")
		def legendreSymbol(a, p):
			ls = pow(a, (p-1) / 2, p)
			return -1 if ls == p-1 else ls
	| 平方剰余であることを確認したら，具体的にどのような\(n\)が\(n^2=a \mod p\)を満たすのかを求める必要がある．今回は詳しい説明は記載しないが，以下にこのプログラムを記載する．ここではTonelli-Shanksアルゴリズムを利用した．
	:code(lang="python")
		def modSqrt(a, p):
			L = legendreSymbol(a, p)
			if L == -1:
				raise Exception(“逆数が存在しません”)
			elif L == 0:
				return 0
			elif p == 2:
				return a # a=1->n=1
			# p-1 = s*2^eなるsとeを計算する
			s = (p - 1)>>1
			e = 0
			while s & 1 == 0:
				s >>= 1
				e += 1
			# L(n/p) = -1なるnを見つける
			n = 2
			while legendreSymbol(n, p) != -1:
				n += 1
			# 根を計算する
			x = pow(a, (s + 1)/2, p)
			b = pow(a, s, p)
			g = pow(n, s, p)
			while True:
				t, m = b, 0
				for m in xrange(e):
					if t == 1:
						break
					t = pow(t, 2, p)
				if m == 0:
					return x
				gs = pow(g, 2 ** (r - m - 1), p)
				g = (gs ** 2) % p
				x = (x * gs) % p
				b = (b * g) % p
				e = m
			return 
